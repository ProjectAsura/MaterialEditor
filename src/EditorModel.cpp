//-----------------------------------------------------------------------------
// File : EditorModel.cpp
// Desc : Model For Editor.
// Copyright(c) Project Asura. All right reserved.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
#include <EditorModel.h>
#include <MeshLoader.h>
#include <asdxLogger.h>


namespace {


} // namespace


///////////////////////////////////////////////////////////////////////////////
// EditorModel class
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//      コンストラクタです.
//-----------------------------------------------------------------------------
EditorModel::EditorModel()
: m_Scale       (1.0f, 1.0f, 1.0f)
, m_Rotation    (0.0f, 0.0f, 0.0f)
, m_Translation (0.0f, 0.0f, 0.0f)
, m_World       (asdx::Matrix::CreateIdentity())
, m_ShaderType  (MS_SHADER_0)
{ /* DO_NOTHING */ }

//-----------------------------------------------------------------------------
//      デストラクタです.
//-----------------------------------------------------------------------------
EditorModel::~EditorModel()
{ Term(); }

//-----------------------------------------------------------------------------
//      初期化処理を行います.
//-----------------------------------------------------------------------------
bool EditorModel::Init(const char* path)
{
    asdx::ResModel res;
    MeshLoader loader;
    if (!loader.Load(path, res))
    {
        ELOGA("Error : MeshLoader::Load() Failed.");
        return false;
    }

    // 頂点カラーがない場合は生成.
    for(size_t i=0; i<res.Meshes.size(); ++i)
    {
        if (res.Meshes[i].Colors.empty())
        {
            auto count = res.Meshes[i].Positions.size();
            res.Meshes[i].Colors.resize(count);
            for(auto j=0; j<count; ++j)
            { res.Meshes[i].Colors[j] = UINT32_MAX; }
        }
    }

    // リソースからシェーダバリエーションを決定.
    {
    }

    if (!m_Model.Init(res))
    {
        ELOGA("Error : Model::Init() Failed.");
        return false;
    }

    return true;
}

//-----------------------------------------------------------------------------
//      終了処理を行います.
//-----------------------------------------------------------------------------
void EditorModel::Term()
{
    m_Model.Term();
}

//-----------------------------------------------------------------------------
//      メッシュ数を取得します.
//-----------------------------------------------------------------------------
uint32_t EditorModel::GetMeshCount() const
{ return m_Model.GetMeshCount(); }

//-----------------------------------------------------------------------------
//      メッシュを取得します.
//-----------------------------------------------------------------------------
const asdx::Mesh& EditorModel::GetMesh(uint32_t index) const
{ return m_Model.GetMesh(index); }

//-----------------------------------------------------------------------------
//      バウンディングボックスを取得します.
//-----------------------------------------------------------------------------
const asdx::BoundingBox& EditorModel::GetBox() const
{ return m_Model.GetBox(); }

//-----------------------------------------------------------------------------
//      シェーダタイプを取得します.
//-----------------------------------------------------------------------------
MS_SHADER_TYPE EditorModel::GetShaderType() const
{ return m_ShaderType; }

//-----------------------------------------------------------------------------
//      ファイルパスを取得します.
//-----------------------------------------------------------------------------
const std::string& EditorModel::GetPath() const
{ return m_Path; }

//-----------------------------------------------------------------------------
//      ワールド行列を取得します.
//-----------------------------------------------------------------------------
const asdx::Matrix& EditorModel::GetWorld() const
{ return m_World; }

//-----------------------------------------------------------------------------
//      スケールを設定します.
//-----------------------------------------------------------------------------
void EditorModel::SetScale(const asdx::Vector3& value)
{
    m_Scale = value;
    UpdateWorld();
}

//-----------------------------------------------------------------------------
//      回転角を設定します.
//-----------------------------------------------------------------------------
void EditorModel::SetRotate(const asdx::Vector3& value)
{
    m_Rotation = value;
    UpdateWorld();
}

//-----------------------------------------------------------------------------
//      平行移動量を設定します.
//-----------------------------------------------------------------------------
void EditorModel::SetTranslation(const asdx::Vector3& value)
{
    m_Translation = value;
    UpdateWorld();
}

//-----------------------------------------------------------------------------
//      スケールを取得します.
//-----------------------------------------------------------------------------
const asdx::Vector3& EditorModel::GetScale() const
{ return m_Scale; }

//-----------------------------------------------------------------------------
//      回転角を取得します.
//-----------------------------------------------------------------------------
const asdx::Vector3& EditorModel::GetRotate() const
{ return m_Rotation; }

//-----------------------------------------------------------------------------
//      平行移動量を取得します.
//-----------------------------------------------------------------------------
const asdx::Vector3& EditorModel::GetTranslation() const
{ return m_Translation; }

//-----------------------------------------------------------------------------
//      ワールド行列を更新します.
//-----------------------------------------------------------------------------
void EditorModel::UpdateWorld()
{
    m_World  = asdx::Matrix::CreateScale(m_Scale); 
    m_World *= asdx::Matrix::CreateRotationX(asdx::ToRadian(m_Rotation.x));
    m_World *= asdx::Matrix::CreateRotationY(asdx::ToRadian(m_Rotation.y));
    m_World *= asdx::Matrix::CreateRotationZ(asdx::ToRadian(m_Rotation.z));
    m_World._41 = m_Translation.x;
    m_World._42 = m_Translation.y;
    m_World._43 = m_Translation.z;
}